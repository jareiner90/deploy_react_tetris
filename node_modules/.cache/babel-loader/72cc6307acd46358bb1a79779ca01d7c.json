{"ast":null,"code":"export var STAGE_WIDTH=12;export var STAGE_HEIGHT=20;export var createStage=function createStage(){return Array.from(Array(STAGE_HEIGHT),function(){return new Array(STAGE_WIDTH).fill([0,'clear']);});};export var checkCollision=function checkCollision(player,stage,_ref){var moveX=_ref.x,moveY=_ref.y;for(var y=0;y<player.tetromino.length;y+=1){for(var x=0;x<player.tetromino[y].length;x+=1){// 1. Check that we're on an actual Tetromino cell\nif(player.tetromino[y][x]!==0){if(// 2. Check that our move is inside the game areas height (y)\n// We shouldn't go through the bottom of the play area\n!stage[y+player.pos.y+moveY]||// 3. Check that our move is inside the game areas width (x)\n!stage[y+player.pos.y+moveY][x+player.pos.x+moveX]||// 4. Check that the cell wer'e moving to isn't set to clear\nstage[y+player.pos.y+moveY][x+player.pos.x+moveX][1]!=='clear'){return true;}}}}};","map":{"version":3,"sources":["/Users/johnreiner/Development/personalProjects/tetris-in-react/src/gameHelpers.js"],"names":["STAGE_WIDTH","STAGE_HEIGHT","createStage","Array","from","fill","checkCollision","player","stage","moveX","x","moveY","y","tetromino","length","pos"],"mappings":"AAAA,MAAO,IAAMA,CAAAA,WAAW,CAAG,EAApB,CACP,MAAO,IAAMC,CAAAA,YAAY,CAAG,EAArB,CAEP,MAAO,IAAMC,CAAAA,WAAW,CAAG,QAAdA,CAAAA,WAAc,SACzBC,CAAAA,KAAK,CAACC,IAAN,CAAWD,KAAK,CAACF,YAAD,CAAhB,CAAgC,iBAC9B,IAAIE,CAAAA,KAAJ,CAAUH,WAAV,EAAuBK,IAAvB,CAA4B,CAAC,CAAD,CAAI,OAAJ,CAA5B,CAD8B,EAAhC,CADyB,EAApB,CAKP,MAAO,IAAMC,CAAAA,cAAc,CAAG,QAAjBA,CAAAA,cAAiB,CAACC,MAAD,CAASC,KAAT,MAA2C,IAAtBC,CAAAA,KAAsB,MAAzBC,CAAyB,CAAZC,KAAY,MAAfC,CAAe,CACvE,IAAK,GAAIA,CAAAA,CAAC,CAAG,CAAb,CAAgBA,CAAC,CAAGL,MAAM,CAACM,SAAP,CAAiBC,MAArC,CAA6CF,CAAC,EAAI,CAAlD,CAAqD,CACnD,IAAK,GAAIF,CAAAA,CAAC,CAAG,CAAb,CAAgBA,CAAC,CAAGH,MAAM,CAACM,SAAP,CAAiBD,CAAjB,EAAoBE,MAAxC,CAAgDJ,CAAC,EAAI,CAArD,CAAwD,CACtD;AACA,GAAIH,MAAM,CAACM,SAAP,CAAiBD,CAAjB,EAAoBF,CAApB,IAA2B,CAA/B,CAAkC,CAChC,GACE;AACA;AACA,CAACF,KAAK,CAACI,CAAC,CAAGL,MAAM,CAACQ,GAAP,CAAWH,CAAf,CAAmBD,KAApB,CAAN,EACA;AACA,CAACH,KAAK,CAACI,CAAC,CAAGL,MAAM,CAACQ,GAAP,CAAWH,CAAf,CAAmBD,KAApB,CAAL,CAAgCD,CAAC,CAAGH,MAAM,CAACQ,GAAP,CAAWL,CAAf,CAAmBD,KAAnD,CAFD,EAGA;AACAD,KAAK,CAACI,CAAC,CAAGL,MAAM,CAACQ,GAAP,CAAWH,CAAf,CAAmBD,KAApB,CAAL,CAAgCD,CAAC,CAAGH,MAAM,CAACQ,GAAP,CAAWL,CAAf,CAAmBD,KAAnD,EAA0D,CAA1D,IACE,OARJ,CASE,CACA,MAAO,KAAP,CACD,CACF,CACF,CACF,CACF,CApBM","sourcesContent":["export const STAGE_WIDTH = 12;\nexport const STAGE_HEIGHT = 20;\n\nexport const createStage = () =>\n  Array.from(Array(STAGE_HEIGHT), () =>\n    new Array(STAGE_WIDTH).fill([0, 'clear']),\n  );\n\nexport const checkCollision = (player, stage, { x: moveX, y: moveY }) => {\n  for (let y = 0; y < player.tetromino.length; y += 1) {\n    for (let x = 0; x < player.tetromino[y].length; x += 1) {\n      // 1. Check that we're on an actual Tetromino cell\n      if (player.tetromino[y][x] !== 0) {\n        if (\n          // 2. Check that our move is inside the game areas height (y)\n          // We shouldn't go through the bottom of the play area\n          !stage[y + player.pos.y + moveY] ||\n          // 3. Check that our move is inside the game areas width (x)\n          !stage[y + player.pos.y + moveY][x + player.pos.x + moveX] ||\n          // 4. Check that the cell wer'e moving to isn't set to clear\n          stage[y + player.pos.y + moveY][x + player.pos.x + moveX][1] !==\n            'clear'\n        ) {\n          return true;\n        }\n      }\n    }\n  }\n};"]},"metadata":{},"sourceType":"module"}