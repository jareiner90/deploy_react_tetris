{"ast":null,"code":"import _slicedToArray from\"/Users/johnreiner/Development/personalProjects/tetris-in-react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import{useState,useEffect}from'react';import{createStage}from'../gameHelpers';export var useStage=function useStage(player,resetPlayer){var _useState=useState(createStage()),_useState2=_slicedToArray(_useState,2),stage=_useState2[0],setStage=_useState2[1];var _useState3=useState(0),_useState4=_slicedToArray(_useState3,2),rowsCleared=_useState4[0],setRowsCleared=_useState4[1];useEffect(function(){setRowsCleared(0);var sweepRows=function sweepRows(newStage){return newStage.reduce(function(ack,row){if(row.findIndex(function(cell){return cell[0]===0;})===-1){setRowsCleared(function(prev){return prev+1;});ack.unshift(new Array(newStage[0].length).fill([0,'clear']));return ack;}ack.push(row);return ack;},[]);};var updateStage=function updateStage(prevStage){// First flush the stage\nvar newStage=prevStage.map(function(row){return row.map(function(cell){return cell[1]==='clear'?[0,'clear']:cell;});});// Then draw the tetromino\nplayer.tetromino.forEach(function(row,y){row.forEach(function(value,x){if(value!==0){newStage[y+player.pos.y][x+player.pos.x]=[value,\"\".concat(player.collided?'merged':'clear')];}});});// Then check if we collided\nif(player.collided){resetPlayer();return sweepRows(newStage);}return newStage;};setStage(function(prev){return updateStage(prev);});},[player,resetPlayer]);return[stage,setStage,rowsCleared];};","map":{"version":3,"sources":["/Users/johnreiner/Development/personalProjects/tetris-in-react/src/hooks/useStage.js"],"names":["useState","useEffect","createStage","useStage","player","resetPlayer","stage","setStage","rowsCleared","setRowsCleared","sweepRows","newStage","reduce","ack","row","findIndex","cell","prev","unshift","Array","length","fill","push","updateStage","prevStage","map","tetromino","forEach","y","value","x","pos","collided"],"mappings":"qLAAA,OAASA,QAAT,CAAmBC,SAAnB,KAAoC,OAApC,CACA,OAASC,WAAT,KAA4B,gBAA5B,CAEA,MAAO,IAAMC,CAAAA,QAAQ,CAAG,QAAXA,CAAAA,QAAW,CAACC,MAAD,CAASC,WAAT,CAAyB,eACrBL,QAAQ,CAACE,WAAW,EAAZ,CADa,wCACxCI,KADwC,eACjCC,QADiC,8BAETP,QAAQ,CAAC,CAAD,CAFC,yCAExCQ,WAFwC,eAE3BC,cAF2B,eAI/CR,SAAS,CAAC,UAAM,CAEdQ,cAAc,CAAC,CAAD,CAAd,CAEA,GAAMC,CAAAA,SAAS,CAAG,QAAZA,CAAAA,SAAY,CAAAC,QAAQ,QACxBA,CAAAA,QAAQ,CAACC,MAAT,CAAgB,SAACC,GAAD,CAAMC,GAAN,CAAc,CAC5B,GAAIA,GAAG,CAACC,SAAJ,CAAc,SAAAC,IAAI,QAAIA,CAAAA,IAAI,CAAC,CAAD,CAAJ,GAAY,CAAhB,EAAlB,IAAyC,CAAC,CAA9C,CAAiD,CAC/CP,cAAc,CAAC,SAAAQ,IAAI,QAAIA,CAAAA,IAAI,CAAG,CAAX,EAAL,CAAd,CACAJ,GAAG,CAACK,OAAJ,CAAY,GAAIC,CAAAA,KAAJ,CAAUR,QAAQ,CAAC,CAAD,CAAR,CAAYS,MAAtB,EAA8BC,IAA9B,CAAmC,CAAC,CAAD,CAAI,OAAJ,CAAnC,CAAZ,EACA,MAAOR,CAAAA,GAAP,CACD,CACDA,GAAG,CAACS,IAAJ,CAASR,GAAT,EACA,MAAOD,CAAAA,GAAP,CACD,CARD,CAQG,EARH,CADwB,EAA1B,CAWA,GAAMU,CAAAA,WAAW,CAAG,QAAdA,CAAAA,WAAc,CAAAC,SAAS,CAAI,CAC/B;AACA,GAAMb,CAAAA,QAAQ,CAAGa,SAAS,CAACC,GAAV,CAAc,SAAAX,GAAG,QAChCA,CAAAA,GAAG,CAACW,GAAJ,CAAQ,SAAAT,IAAI,QAAKA,CAAAA,IAAI,CAAC,CAAD,CAAJ,GAAY,OAAZ,CAAsB,CAAC,CAAD,CAAI,OAAJ,CAAtB,CAAqCA,IAA1C,EAAZ,CADgC,EAAjB,CAAjB,CAIA;AACAZ,MAAM,CAACsB,SAAP,CAAiBC,OAAjB,CAAyB,SAACb,GAAD,CAAMc,CAAN,CAAY,CACnCd,GAAG,CAACa,OAAJ,CAAY,SAACE,KAAD,CAAQC,CAAR,CAAc,CACxB,GAAID,KAAK,GAAK,CAAd,CAAiB,CACflB,QAAQ,CAACiB,CAAC,CAAGxB,MAAM,CAAC2B,GAAP,CAAWH,CAAhB,CAAR,CAA2BE,CAAC,CAAG1B,MAAM,CAAC2B,GAAP,CAAWD,CAA1C,EAA+C,CAC7CD,KAD6C,WAE1CzB,MAAM,CAAC4B,QAAP,CAAkB,QAAlB,CAA6B,OAFa,EAA/C,CAID,CACF,CAPD,EAQD,CATD,EAUA;AACA,GAAI5B,MAAM,CAAC4B,QAAX,CAAqB,CACnB3B,WAAW,GACX,MAAOK,CAAAA,SAAS,CAACC,QAAD,CAAhB,CACD,CAED,MAAOA,CAAAA,QAAP,CACD,CAxBD,CA0BAJ,QAAQ,CAAC,SAAAU,IAAI,QAAIM,CAAAA,WAAW,CAACN,IAAD,CAAf,EAAL,CAAR,CACD,CA1CQ,CA0CN,CAACb,MAAD,CAASC,WAAT,CA1CM,CAAT,CA4CA,MAAO,CAACC,KAAD,CAAQC,QAAR,CAAkBC,WAAlB,CAAP,CACD,CAjDM","sourcesContent":["import { useState, useEffect } from 'react';\nimport { createStage } from '../gameHelpers';\n\nexport const useStage = (player, resetPlayer) => {\n  const [stage, setStage] = useState(createStage());\n  const [rowsCleared, setRowsCleared] = useState(0);\n\n  useEffect(() => {\n\n    setRowsCleared(0);\n\n    const sweepRows = newStage => \n      newStage.reduce((ack, row) => {\n        if (row.findIndex(cell => cell[0] === 0) === -1) {\n          setRowsCleared(prev => prev + 1);\n          ack.unshift(new Array(newStage[0].length).fill([0, 'clear']));\n          return ack;\n        }\n        ack.push(row);\n        return ack;\n      }, [])\n\n    const updateStage = prevStage => {\n      // First flush the stage\n      const newStage = prevStage.map(row =>\n        row.map(cell => (cell[1] === 'clear' ? [0, 'clear'] : cell)),\n      );\n\n      // Then draw the tetromino\n      player.tetromino.forEach((row, y) => {\n        row.forEach((value, x) => {\n          if (value !== 0) {\n            newStage[y + player.pos.y][x + player.pos.x] = [\n              value,\n              `${player.collided ? 'merged' : 'clear'}`,\n            ];\n          }\n        });\n      });\n      // Then check if we collided\n      if (player.collided) {\n        resetPlayer();\n        return sweepRows(newStage)\n      }\n\n      return newStage;\n    };\n\n    setStage(prev => updateStage(prev));\n  }, [player, resetPlayer]);\n\n  return [stage, setStage, rowsCleared];\n};\n"]},"metadata":{},"sourceType":"module"}