{"ast":null,"code":"import _objectSpread from\"/Users/johnreiner/Development/personalProjects/tetris-in-react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _slicedToArray from\"/Users/johnreiner/Development/personalProjects/tetris-in-react/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import{useState,useCallback}from'react';import{TETROMINOS,randomTetromino}from'../tetrominos';import{STAGE_WIDTH,checkCollision}from'../gameHelpers';export var usePlayer=function usePlayer(){var _useState=useState({pos:{x:0,y:0},tetromino:TETROMINOS[0].shape,collided:false}),_useState2=_slicedToArray(_useState,2),player=_useState2[0],setPlayer=_useState2[1];var rotate=function rotate(matrix,dir){// make rows into cols \nvar rotatedTetro=matrix.map(function(_,index){return matrix.map(function(col){return col[index];});});// reverse each row to get a rotated matix\nif(dir>0)return rotatedTetro.map(function(row){return row.reverse();});return rotatedTetro.reverse();};var playerRotate=function playerRotate(stage,dir){var clonedPlayer=JSON.parse(JSON.stringify(player));clonedPlayer.tetromino=rotate(clonedPlayer.tetromino,dir);var pos=clonedPlayer.pos.x;var offset=1;while(checkCollision(clonedPlayer,stage,{x:0,y:0})){clonedPlayer.pos.x+=offset;offset=-(offset+(offset>0?1:-1));if(offset>clonedPlayer.tetromino[0].length){rotate(clonedPlayer.tetromino,-dir);clonedPlayer.pos.x=pos;return;}}setPlayer(clonedPlayer);};var updatePlayerPos=function updatePlayerPos(_ref){var x=_ref.x,y=_ref.y,collided=_ref.collided;setPlayer(function(prev){return _objectSpread(_objectSpread({},prev),{},{pos:{x:prev.pos.x+=x,y:prev.pos.y+=y},collided:collided});});};var resetPlayer=useCallback(function(){setPlayer({pos:{x:STAGE_WIDTH/2-2,y:0},tetromino:randomTetromino().shape,collided:false});},[]);return[player,updatePlayerPos,resetPlayer,playerRotate];};","map":{"version":3,"sources":["/Users/johnreiner/Development/personalProjects/tetris-in-react/src/hooks/usePlayer.js"],"names":["useState","useCallback","TETROMINOS","randomTetromino","STAGE_WIDTH","checkCollision","usePlayer","pos","x","y","tetromino","shape","collided","player","setPlayer","rotate","matrix","dir","rotatedTetro","map","_","index","col","row","reverse","playerRotate","stage","clonedPlayer","JSON","parse","stringify","offset","length","updatePlayerPos","prev","resetPlayer"],"mappings":"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","sourcesContent":["import { useState, useCallback } from 'react';\n\nimport { TETROMINOS, randomTetromino } from '../tetrominos';\nimport { STAGE_WIDTH, checkCollision } from '../gameHelpers';\n\nexport const usePlayer = () => {\n  const [player, setPlayer] = useState({\n    pos: { x: 0, y: 0 },\n    tetromino: TETROMINOS[0].shape,\n    collided: false,\n  });\n\n  const rotate = (matrix, dir) => {\n    // make rows into cols \n\n    const rotatedTetro = matrix.map((_, index) => \n      matrix.map (col => col[index]),\n      );\n    // reverse each row to get a rotated matix\n    if (dir > 0) return rotatedTetro.map(row => row.reverse());\n    return rotatedTetro.reverse()\n  };\n\n  const playerRotate = (stage, dir) => {\n    const clonedPlayer = JSON.parse(JSON.stringify(player));\n    clonedPlayer.tetromino = rotate(clonedPlayer.tetromino, dir);\n\n    const pos = clonedPlayer.pos.x;\n    let offset = 1;\n    while (checkCollision(clonedPlayer, stage, { x: 0, y: 0 })) {\n      clonedPlayer.pos.x += offset;\n      offset = -(offset + (offset >  0 ? 1 : -1));\n      if (offset > clonedPlayer.tetromino[0].length) {\n        rotate(clonedPlayer.tetromino, -dir);\n        clonedPlayer.pos.x = pos;\n        return;\n      }\n    }\n\n    setPlayer(clonedPlayer);\n  }\n\n  const updatePlayerPos = ({ x, y, collided }) => {\n    setPlayer(prev => ({\n      ...prev,\n      pos: { x: (prev.pos.x += x), y: (prev.pos.y += y)},\n      collided,\n    }))\n  }\n\n  const resetPlayer = useCallback(() => {\n    setPlayer({\n      pos: { x: STAGE_WIDTH / 2 - 2, y: 0 },\n      tetromino: randomTetromino().shape,\n      collided: false,\n    })\n  }, [])\n\n  return [player, updatePlayerPos, resetPlayer, playerRotate];\n}"]},"metadata":{},"sourceType":"module"}